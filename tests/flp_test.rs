use prio::{
    field::{random_vector, Field64},
    flp::{types::Count, FlpError},
    vdaf::xof::{IntoFieldVec, Xof, XofShake128},
};
use rand::{thread_rng, Rng};
use rand_core::RngCore;
use rayon::prelude::{IndexedParallelIterator, IntoParallelRefIterator, ParallelIterator};

#[test]
fn flp_bool_beta() {
    // The same verify_key for the Aggregators. Needs to be random for different sessions.
    let mut verify_key = [0; 16];
    thread_rng().fill(&mut verify_key);

    let typ = Count::<Field64>::new();

    assert!(run_flp_with_input(&verify_key, &typ, 0).unwrap());
    assert!(run_flp_with_input(&verify_key, &typ, 1).unwrap());

    // The following two should panic with an FLP error as the input is not in range.
    assert!(run_flp_with_input(&verify_key, &typ, 2).is_err());
    assert!(run_flp_with_input(&verify_key, &typ, 100).is_err());
}

#[test]
fn flp_random_beta_in_range() {
    let typ = Count::<Field64>::new();

    // The same verify_key for the Aggregators. Needs to be random for different sessions.
    let mut verify_key = [0; 16];
    thread_rng().fill(&mut verify_key);

    assert!(run_flp_with_input(&verify_key, &typ, 0).unwrap());
    assert!(run_flp_with_input(&verify_key, &typ, 1).unwrap());

    // The following two should panic with an FLP error as the input is not in range.
    assert!(run_flp_with_input(&verify_key, &typ, 2).is_err());
    assert!(run_flp_with_input(&verify_key, &typ, 3).is_err());
    assert!(run_flp_with_input(&verify_key, &typ, 4).is_err());
    assert!(run_flp_with_input(&verify_key, &typ, 100).is_err());
}

fn run_flp_with_input<T>(verify_key: &[u8; 16], typ: &T, input: u64) -> Result<bool, FlpError>
where
    T: prio::flp::Type<Field = Field64, Measurement = u64>,
{
    // 1. The Prover chooses a measurement and secret shares the input.
    let input: Vec<Field64> = typ.encode_measurement(&input)?;
    let input_0 = input
        .iter()
        .map(|_| Field64::from(rand::thread_rng().gen::<u64>()))
        .collect::<Vec<_>>();
    let input_1 = input
        .par_iter()
        .zip(input_0.par_iter())
        .map(|(in_0, in_1)| in_0 - in_1)
        .collect::<Vec<_>>();

    // Nonce is generated by the Prover. Needs to be random.
    let nonce = rand::thread_rng().gen::<u128>().to_le_bytes();

    // 2. The Prover generates prove_rand and query_rand (should be unique per proof). The Prover
    //    uses prover_rand to generate the proof. Finally, the Prover secret shares the proof.
    let prove_rand = random_vector(typ.prove_rand_len()).unwrap();
    let query_rand_xof = XofShake128::init(&verify_key, &nonce);
    let query_rand: Vec<Field64> = query_rand_xof
        .clone()
        .into_seed_stream()
        .into_field_vec(typ.query_rand_len());
    let mut vidpf_seeds = ([0u8; 16], [0u8; 16]);
    thread_rng().fill(&mut vidpf_seeds.0);
    thread_rng().fill(&mut vidpf_seeds.1);

    let mut jr_parts = [[0u8; 16]; 2];
    // Assume that we have the two VIDPF seeds.
    let mut jr_part_0_xof = XofShake128::init(&vidpf_seeds.0, &[0u8; 16]);
    jr_part_0_xof.update(&[0]); // Aggregator ID
    jr_part_0_xof.update(&nonce);
    jr_part_0_xof
        .into_seed_stream()
        .fill_bytes(&mut jr_parts[0]);

    let mut jr_part_1_xof = XofShake128::init(&vidpf_seeds.1, &[0u8; 16]);
    jr_part_1_xof.update(&[1]); // Aggregator ID
    jr_part_1_xof.update(&nonce);
    jr_part_1_xof
        .into_seed_stream()
        .fill_bytes(&mut jr_parts[1]);

    let joint_rand_xof = XofShake128::init(&jr_parts[0], &jr_parts[1]);
    let joint_rand: Vec<Field64> = joint_rand_xof
        .into_seed_stream()
        .into_field_vec(typ.joint_rand_len());

    let proof = typ.prove(&input, &prove_rand, &joint_rand).unwrap();
    let proof_0 = proof
        .iter()
        .map(|_| Field64::from(rand::thread_rng().gen::<u64>()))
        .collect::<Vec<_>>();
    let proof_1 = proof
        .par_iter()
        .zip(proof_0.par_iter())
        .map(|(p_0, p_1)| p_0 - p_1)
        .collect::<Vec<_>>();

    // 3. The Verifiers are provided with the nonce for each Client and can generate the query_rand
    //    (should be the same between the Verifiers). Each Verifier queries the input and proof
    //    shares and receives a verifier_share.
    let verifier_0 = typ
        .query(&input_0, &proof_0, &query_rand, &joint_rand, 2)
        .unwrap();
    let verifier_1 = typ
        .query(&input_1, &proof_1, &query_rand, &joint_rand, 2)
        .unwrap();

    // 4. The Verifiers combined their verifier_shares to check the proof.
    let verifier = verifier_0
        .par_iter()
        .zip(verifier_1.par_iter())
        .map(|(v1, v2)| v1 + v2)
        .collect::<Vec<_>>();

    typ.decide(&verifier)
}
