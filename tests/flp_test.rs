use mastic::{Mastic, MasticHistogram};
use prio::{
    field::{random_vector, Field128},
    flp::FlpError,
    vdaf::xof::{IntoFieldVec, Xof, XofShake128},
};
use rand::{thread_rng, Rng};
use rand_core::RngCore;
use rayon::prelude::{IndexedParallelIterator, IntoParallelRefIterator, ParallelIterator};

#[test]
fn histograms() {
    let buckets = 10;

    // The same verify_key for the Aggregators. Needs to be random for different sessions.
    let mut verify_key = [0; 16];
    thread_rng().fill(&mut verify_key);

    let mastic = Mastic::new_histogram(buckets).unwrap();

    assert!(run_flp_with_input(&verify_key, &mastic, 0).unwrap());
    assert!(run_flp_with_input(&verify_key, &mastic, 1).unwrap());
    assert!(run_flp_with_input(&verify_key, &mastic, 2).unwrap());
    assert!(run_flp_with_input(&verify_key, &mastic, 3).unwrap());
    assert!(run_flp_with_input(&verify_key, &mastic, 4).unwrap());
}

fn run_flp_with_input(
    verify_key: &[u8; 16],
    mastic: &MasticHistogram,
    input: usize,
) -> Result<bool, FlpError> {
    // 1. The Prover chooses a measurement and secret shares the input.
    let input = mastic.encode_measurement(&input).unwrap();
    let input_0 = input
        .iter()
        .map(|_| Field128::from(rand::thread_rng().gen::<u128>()))
        .collect::<Vec<_>>();
    let input_1 = input
        .par_iter()
        .zip(input_0.par_iter())
        .map(|(in_0, in_1)| in_0 - in_1)
        .collect::<Vec<_>>();

    // Nonce is generated by the Prover. Needs to be random.
    let nonce = rand::thread_rng().gen::<u128>().to_le_bytes();

    // 2. The Prover generates prove_rand and query_rand (should be unique per proof). The Prover
    //    uses prover_rand to generate the proof. Finally, the Prover secret shares the proof.
    let prove_rand = random_vector(mastic.prove_rand_len()).unwrap();
    let query_rand_xof = XofShake128::init(&verify_key, &nonce);
    let query_rand: Vec<Field128> = query_rand_xof
        .clone()
        .into_seed_stream()
        .into_field_vec(mastic.query_rand_len());
    let mut vidpf_seeds = ([0u8; 16], [0u8; 16]);
    thread_rng().fill(&mut vidpf_seeds.0);
    thread_rng().fill(&mut vidpf_seeds.1);

    let mut jr_parts = [[0u8; 16]; 2];
    // Assume that we have the two VIDPF seeds.
    let mut jr_part_0_xof = XofShake128::init(&vidpf_seeds.0, &[0u8; 16]);
    jr_part_0_xof.update(&[0]); // Aggregator ID
    jr_part_0_xof.update(&nonce);
    jr_part_0_xof
        .into_seed_stream()
        .fill_bytes(&mut jr_parts[0]);

    let mut jr_part_1_xof = XofShake128::init(&vidpf_seeds.1, &[0u8; 16]);
    jr_part_1_xof.update(&[1]); // Aggregator ID
    jr_part_1_xof.update(&nonce);
    jr_part_1_xof
        .into_seed_stream()
        .fill_bytes(&mut jr_parts[1]);

    let joint_rand_xof = XofShake128::init(&jr_parts[0], &jr_parts[1]);
    let joint_rand: Vec<Field128> = joint_rand_xof
        .into_seed_stream()
        .into_field_vec(mastic.joint_rand_len());

    let proof = mastic.prove(&input, &prove_rand, &joint_rand).unwrap();
    let proof_0 = proof
        .iter()
        .map(|_| Field128::from(rand::thread_rng().gen::<u128>()))
        .collect::<Vec<_>>();
    let proof_1 = proof
        .par_iter()
        .zip(proof_0.par_iter())
        .map(|(p_0, p_1)| p_0 - p_1)
        .collect::<Vec<_>>();

    // 3. The Verifiers are provided with the nonce for each Client and can generate the query_rand
    //    (should be the same between the Verifiers). Each Verifier queries the input and proof
    //    shares and receives a verifier_share.
    let verifier_0 = mastic
        .query(&input_0, &proof_0, &query_rand, &joint_rand, 2)
        .unwrap();
    let verifier_1 = mastic
        .query(&input_1, &proof_1, &query_rand, &joint_rand, 2)
        .unwrap();

    // 4. The Verifiers combined their verifier_shares to check the proof.
    let verifier = verifier_0
        .par_iter()
        .zip(verifier_1.par_iter())
        .map(|(v1, v2)| v1 + v2)
        .collect::<Vec<_>>();

    mastic.decide(&verifier)
}
